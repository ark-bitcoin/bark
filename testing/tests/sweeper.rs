use std::time::Duration;
use std::sync::Arc;
use log::info;

use server_log::{
	NotSweeping, BoardFullySwept, RoundFinished, RoundFullySwept,
	SweepBroadcast, SweeperStats, SweepingOutput, TxIndexUpdateFinished,
};

use ark::ProtocolEncoding;
use bitcoin_ext::DEEPLY_CONFIRMED;
use server_rpc::protos;


use ark_testing::{TestContext, sat};
use ark_testing::constants::BOARD_CONFIRMATIONS;
use ark_testing::util::{FutureExt, ReceiverExt};

#[ignore]
#[tokio::test]
async fn sweep_board_and_oor() {
	let ctx = TestContext::new("sweeper/sweep_board").await;

	let vtxo_lifetime = 64;
	let srv = ctx.new_captaind_with_cfg("server", None, |cfg| {
		cfg.round_interval = Duration::from_millis(500000000);
		cfg.vtxo_lifetime = vtxo_lifetime;
		cfg.vtxo_sweeper.enabled_mut().unwrap().sweep_threshold = sat(100_000);
	}).await;
	ctx.fund_captaind(&srv, sat(1_000_000)).await;

	// Create a board and spend it
	// We should have at least two vtxos that originate from the same board
	let bark = ctx.new_bark_with_funds("bark", &srv, sat(500_000)).await;
	bark.board_all().await;
	ctx.generate_blocks(BOARD_CONFIRMATIONS).await;
	let addr = bark.address().await;
	bark.send_oor(&addr, sat(10_000)).await;
	assert_eq!(bark.vtxos().await.len(), 2);

	// Make the board expire so we can sweep it
	ctx.generate_blocks(vtxo_lifetime as u32).await;

	// subscribe to a few log messages
	let mut log_sweeping = srv.subscribe_log::<SweepBroadcast>();
	let mut log_sweeps = srv.subscribe_log::<SweepingOutput>();

	srv.wait_for_log::<TxIndexUpdateFinished>().wait(6_000).await;
	srv.trigger_sweep().await;

	log_sweeping.recv().wait(15_000).await;
	let sweeps = log_sweeps.collect();
	assert_eq!(1, sweeps.len(), "sweeps: {:?}", sweeps);
	assert_eq!(sweeps[0].sweep_type, "board");
}


#[tokio::test]
async fn sweep_vtxos() {
	//! Testing server spending expired rounds.
	let ctx = TestContext::new("sweeper/sweep_vtxos").await;

	// TODO: in this test, blocks are generated by the server's bitcoin node.
	// Ideally they would be generated by ctx.bitcoind but it will
	// require some synchronization.

	let vtxo_lifetime = 64;
	let srv = ctx.new_captaind_with_cfg("server", None, |cfg| {
		cfg.round_interval = Duration::from_millis(500000000);
		cfg.vtxo_lifetime = vtxo_lifetime;
		cfg.vtxo_sweeper.enabled_mut().unwrap().sweep_threshold = sat(100_000);
	}).await;
	ctx.fund_captaind(&srv, sat(1_000_000)).await;
	let bark = Arc::new(ctx.new_bark_with_funds("bark", &srv, sat(500_000)).await);

	// subscribe to a few log messages
	let mut log_not_sweeping = srv.subscribe_log::<NotSweeping>();
	let mut log_sweeping = srv.subscribe_log::<SweepBroadcast>();
	let mut log_board_done = srv.subscribe_log::<BoardFullySwept>();
	let mut log_round_done = srv.subscribe_log::<RoundFullySwept>();
	let mut log_sweeps = srv.subscribe_log::<SweepingOutput>();

	let board_height_difference = 2;
	// we board one vtxo and then a few blocks later another
	bark.board(sat(75_000)).await;
	ctx.generate_blocks(board_height_difference).await;
	bark.board_and_confirm_and_register(&ctx, sat(75_000)).await;

	// before either expires not sweeping yet because nothing available
	srv.wait_for_log::<TxIndexUpdateFinished>().await;
	srv.trigger_sweep().await;
	assert_eq!(sat(0), log_not_sweeping.recv().wait(15_000).await.unwrap().available_surplus);

	// we can't make vtxos expire, so we have to refresh them
	let b = bark.clone();
	tokio::spawn(async move {
		b.refresh_all().await;
	});
	srv.trigger_round().await;

	let _ = srv.wait_for_log::<RoundFinished>().try_wait(5_000).await;
	ctx.generate_blocks(vtxo_lifetime as u32 - board_height_difference - BOARD_CONFIRMATIONS).await;

	// now we expire the first one, still not sweeping because not enough surplus
	srv.wait_for_log::<TxIndexUpdateFinished>().wait(6_000).await;
	srv.trigger_sweep().await;
	assert_eq!(sat(73_760), log_not_sweeping.recv().wait(15_000).await.unwrap().available_surplus);

	// now we expire the second, but the amount is not enough to sweep
	ctx.generate_blocks(board_height_difference).await;
	srv.wait_for_log::<TxIndexUpdateFinished>().wait(6_000).await;
	srv.trigger_sweep().await;
	let surplus = log_sweeping.recv().wait(15_000).await.unwrap().surplus;
	let sweeps = log_sweeps.collect();
	assert_eq!(2, sweeps.len(), "sweeps: {:?}", sweeps);
	assert_eq!(sweeps[0].sweep_type, "board");
	assert_eq!(sweeps[1].sweep_type, "board");
	assert_eq!(sat(147_520), surplus);

	// now we swept both board vtxos, let's sweep the round we created above
	ctx.generate_blocks(30).await;
	srv.wait_for_log::<TxIndexUpdateFinished>().await;
	srv.trigger_sweep().await;
	let surplus = log_sweeping.recv().wait(15_000).await.unwrap().surplus;
	let sweeps = log_sweeps.collect();
	assert_eq!(1, sweeps.len(), "sweeps: {:?}", sweeps);
	assert_eq!(sweeps[0].sweep_type, "vtxo");
	assert_eq!(sat(149_650), surplus);

	// then after a while, we should sweep the connectors,
	// but they don't make the surplus threshold, so we add another board
	let board = bark.board(sat(102_000)).await;
	ctx.generate_blocks(DEEPLY_CONFIRMED).await;

	// We need to now register this board without triggering bark maintenance.
	let bark_client = bark.client().await;

	let vtxo = bark_client.get_vtxo_by_id(board.vtxos[0].id).unwrap();

	let mut rpc = srv.get_public_rpc().await;
	let request = protos::BoardVtxoRequest {
		board_vtxo: vtxo.vtxo.serialize(),
	};
	rpc.register_board_vtxo(request).await.unwrap();

	srv.wait_for_log::<TxIndexUpdateFinished>().await;
	srv.trigger_sweep().await;
	let surplus = log_sweeping.recv().wait(15_000).await.unwrap().surplus;
	let sweeps = log_sweeps.collect();
	assert_eq!(2, sweeps.len(), "sweeps: {:?}", sweeps);
	assert_eq!(sweeps[0].sweep_type, "connector");
	assert_eq!(sweeps[1].sweep_type, "board");
	assert_eq!(sat(101_255), surplus);

	ctx.generate_blocks(DEEPLY_CONFIRMED).await;
	srv.wait_for_log::<TxIndexUpdateFinished>().await;
	let mut log_stats = srv.subscribe_log::<SweeperStats>();
	srv.trigger_sweep().await;

	// and eventually the round should be finished
	log_board_done.recv().wait(10_000).await.unwrap();
	info!("board done signal received");
	log_round_done.recv().wait(10_000).await.unwrap();
	info!("Round done signal received");
	let stats = log_stats.recv().ready().await.unwrap();
	assert_eq!(0, stats.nb_pending_utxos);
	assert_eq!(1_242_122, srv.wallet_status().await.total().to_sat());
}