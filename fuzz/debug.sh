#!/usr/bin/env bash
set -euo pipefail

REPO_DIR=$(git rev-parse --show-toplevel)
FUZZ_DIR="$REPO_DIR/fuzz"
WORKSPACE_DIR="$FUZZ_DIR/hfuzz_workspace"

# Use GDB instead of LLDB (LLDB has Python integration issues on many systems)
export HFUZZ_DEBUGGER=gdb

# Enable Rust backtraces for better debugging output
export RUST_BACKTRACE=1

usage() {
    cat <<EOF
Bark Fuzzing Debug Helper

Debug crash files generated by honggfuzz. Automatically finds crash files
in the workspace directory and launches GDB for analysis.

USAGE:
    $(basename "$0") [OPTIONS] <TARGET> [CRASH_FILE]

ARGS:
    <TARGET>        Fuzz target to debug (e.g., vtxo_decode, vtxo_getters)
    [CRASH_FILE]    Specific crash file to debug. If omitted, lists available
                    crashes and prompts for selection

OPTIONS:
    -h, --help      Show this help message
    -l, --list      List all crash files for the target and exit
    -a, --all       Debug all crash files sequentially
    -x, --xxd       Show hex dump of crash file instead of debugging

EXAMPLES:
    $(basename "$0") vtxo_getters                    # Interactive: select from crashes
    $(basename "$0") vtxo_getters -l                 # List all crashes for target
    $(basename "$0") vtxo_getters SIGABRT.PC...fuzz  # Debug specific crash file
    $(basename "$0") vtxo_getters -x SIGABRT...fuzz  # View crash file as hex
    $(basename "$0") vtxo_getters -a                 # Debug all crashes sequentially

NOTES:
    - Crash files are stored in hfuzz_workspace/<target>/
    - Uses GDB by default (set HFUZZ_DEBUGGER=lldb to use LLDB)
    - In GDB, use 'run' to execute then 'bt' for backtrace
EOF
}

list_crashes() {
    local target="$1"
    local crash_dir="$WORKSPACE_DIR/$target"

    if [ ! -d "$crash_dir" ]; then
        echo "No workspace directory found for target: $target" >&2
        echo "Run fuzzing first: ./fuzz.sh $target" >&2
        return 1
    fi

    # Find crash files (typically named SIGABRT.*, SIGSEGV.*, etc.)
    local crashes
    crashes=$(find "$crash_dir" -maxdepth 1 -type f -name "SIG*" -o -name "*.fuzz" 2>/dev/null | sort)

    if [ -z "$crashes" ]; then
        echo "No crash files found in $crash_dir" >&2
        return 1
    fi

    echo "$crashes"
}

debug_crash() {
    local target="$1"
    local crash_file="$2"

    echo "=== Debugging $target with crash file ==="
    echo "File: $crash_file"
    echo
    echo "GDB will start. Useful commands:"
    echo "  run     - Execute program with crash input"
    echo "  bt      - Show backtrace after crash"
    echo "  quit    - Exit GDB"
    echo

    cargo hfuzz run-debug "$target" "$crash_file"
}

show_xxd() {
    local crash_file="$1"
    echo "=== Hex dump of crash file ==="
    echo "File: $crash_file"
    echo
    xxd "$crash_file"
}

# Parse arguments
LIST_ONLY=0
DEBUG_ALL=0
SHOW_XXD=0
TARGET=""
CRASH_FILE=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            usage
            exit 0
            ;;
        -l|--list)
            LIST_ONLY=1
            shift
            ;;
        -a|--all)
            DEBUG_ALL=1
            shift
            ;;
        -x|--xxd)
            SHOW_XXD=1
            shift
            ;;
        -*)
            echo "Error: Unknown option $1" >&2
            usage >&2
            exit 1
            ;;
        *)
            if [ -z "$TARGET" ]; then
                TARGET="$1"
            else
                CRASH_FILE="$1"
            fi
            shift
            ;;
    esac
done

# Validate target
if [ -z "$TARGET" ]; then
    echo "Error: Target is required" >&2
    echo >&2
    usage >&2
    exit 1
fi

# List only mode
if [ "$LIST_ONLY" = "1" ]; then
    echo "Crash files for target: $TARGET"
    echo
    list_crashes "$TARGET"
    exit 0
fi

# Get crash files
crashes=$(list_crashes "$TARGET") || exit 1

# If specific crash file provided, resolve its path
if [ -n "$CRASH_FILE" ]; then
    # Check if it's an absolute path or just a filename
    if [ -f "$CRASH_FILE" ]; then
        crash_path="$CRASH_FILE"
    elif [ -f "$WORKSPACE_DIR/$TARGET/$CRASH_FILE" ]; then
        crash_path="$WORKSPACE_DIR/$TARGET/$CRASH_FILE"
    else
        echo "Error: Crash file not found: $CRASH_FILE" >&2
        exit 1
    fi

    if [ "$SHOW_XXD" = "1" ]; then
        show_xxd "$crash_path"
    else
        debug_crash "$TARGET" "$crash_path"
    fi
    exit 0
fi

# Debug all mode
if [ "$DEBUG_ALL" = "1" ]; then
    echo "Debugging all crash files for: $TARGET"
    echo
    for crash in $crashes; do
        if [ "$SHOW_XXD" = "1" ]; then
            show_xxd "$crash"
        else
            debug_crash "$TARGET" "$crash"
        fi
        echo
        echo "Press Enter to continue to next crash, or Ctrl+C to exit..."
        read -r
    done
    exit 0
fi

# Interactive selection
echo "Available crash files for target: $TARGET"
echo

crash_array=()
i=1
while IFS= read -r crash; do
    crash_array+=("$crash")
    basename_crash=$(basename "$crash")
    echo "  [$i] $basename_crash"
    ((i++))
done <<< "$crashes"

echo
read -rp "Select crash file [1-$((i-1))]: " selection

if ! [[ "$selection" =~ ^[0-9]+$ ]] || [ "$selection" -lt 1 ] || [ "$selection" -gt "${#crash_array[@]}" ]; then
    echo "Error: Invalid selection" >&2
    exit 1
fi

selected_crash="${crash_array[$((selection-1))]}"

if [ "$SHOW_XXD" = "1" ]; then
    show_xxd "$selected_crash"
else
    debug_crash "$TARGET" "$selected_crash"
fi
