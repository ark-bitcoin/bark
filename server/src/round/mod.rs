
pub mod forfeit;


use std::mem;
use std::borrow::Borrow;
use std::collections::{HashMap, HashSet};
use std::str::FromStr;
use std::sync::Arc;
use std::time::{Duration, SystemTime, UNIX_EPOCH};

use anyhow::Context;
use bitcoin::consensus::encode::serialize;
use bitcoin::{Amount, OutPoint, Psbt, Txid};
use bitcoin::hashes::{sha256, Hash};
use bitcoin::secp256k1::{rand, Keypair, PublicKey};
use bitcoin_ext::{BlockHeight, P2TR_DUST, P2WSH_DUST};
use log::{debug, error, info, log_enabled, trace, warn};
use opentelemetry::global;
use opentelemetry::global::BoxedTracer;
use opentelemetry::trace::{SpanKind, TraceContextExt, Tracer, TracerProvider};
use tokio::sync::{mpsc, oneshot, OwnedMutexGuard};
use tracing::info_span;
use tracing_opentelemetry::OpenTelemetrySpanExt;

use ark::{
	ProtocolEncoding, SignedVtxoRequest, Vtxo, VtxoId, VtxoIdInput, VtxoPolicy, VtxoRequest,
};
use ark::challenges::{NonInteractiveRoundParticipationChallenge, RoundAttemptChallenge};
use ark::musig::{self, PublicNonce, SecretNonce};
use ark::rounds::{
	RoundAttempt, RoundEvent, RoundFinished, RoundSeq, VtxoProposal, ROUND_TX_VTXO_TREE_VOUT,
};
use ark::tree::signed::{
	UnlockHash, UnlockPreimage, UnsignedVtxoTree, VtxoLeafSpec, VtxoTreeSpec,
};
use server_log::{LogMsg, RoundVtxoCreated};

use crate::database::rounds::StoredRoundParticipation;
use crate::{telemetry, Server, SECP};
use crate::error::{ContextExt, NotFound};
use crate::flux::{VtxoFluxGuard, OwnedVtxoFluxGuard};
use crate::telemetry::{MetricsService, RoundStep, SpanExt, TimedRoundStep};
use crate::wallet::{BdkWalletExt, PersistedWallet, WalletUtxoGuard};

#[macro_export]
macro_rules! server_rslog {
	($struct:ident, $step:expr, $( $args:tt )*) => {
		slog!($struct,
			round_seq: $step.round_seq(),
			attempt_seq: $step.attempt_seq(),
			server_duration: $step.duration(),
			$( $args )*
		);
	};
	($struct:ident, $step:expr) => { server_rslog!($struct, $step, ); };
}

#[macro_export]
macro_rules! client_rslog {
	($struct:ident, $step:expr, $( $args:tt )*) => {
		slog!($struct,
			round_seq: $step.round_seq(),
			attempt_seq: $step.attempt_seq(),
			client_duration: $step.duration(),
			$( $args )*
		);
	};
	($struct:ident, $step:expr) => { client_rslog!($struct, $step, ); };
}

#[derive(Debug)]
pub enum RoundInput {
	RegisterPayment {
		inputs: Vec<VtxoIdInput>,
		vtxo_requests: Vec<SignedVtxoRequest>,
		/// the unlock preimage *generated by the server* for this payment
		unlock_preimage: UnlockPreimage,
	},
	VtxoSignatures {
		pubkey: PublicKey,
		signatures: Vec<musig::PartialSignature>,
	},
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct VtxoParticipant {
	pub req: VtxoLeafSpec,
	pub nonces: Option<Vec<PublicNonce>>,
}

impl VtxoParticipant {
	pub fn new_signed(req: SignedVtxoRequest, unlock_hash: UnlockHash) -> VtxoParticipant {
		VtxoParticipant {
			req: VtxoLeafSpec {
				vtxo: req.vtxo,
				cosign_pubkey: Some(req.cosign_pubkey),
				unlock_hash: unlock_hash,
			},
			nonces: Some(req.nonces),
		}
	}

	pub fn new_non_interactive(req: VtxoRequest, unlock_hash: UnlockHash) -> VtxoParticipant {
		VtxoParticipant {
			req: VtxoLeafSpec {
				vtxo: req,
				cosign_pubkey: None,
				unlock_hash: unlock_hash,
			},
			nonces: None,
		}
	}
}

#[derive(Clone)]
pub struct RoundData {
	max_output_vtxos: usize,
	nb_vtxo_nonces: usize,
	max_vtxo_amount: Option<Amount>,
}

pub struct InteractiveParticipation {
	pub(crate) unlock_preimage: UnlockPreimage,
	pub(crate) inputs: Vec<VtxoId>,
	pub(crate) outputs: Vec<VtxoRequest>,
}

pub struct CollectingPayments {
	round_data: RoundData,

	round_attempt_challenge: RoundAttemptChallenge,

	/// All inputs that have participated in the previous attempt.
	locked_inputs: OwnedVtxoFluxGuard,

	cosign_key: Keypair,
	allowed_inputs: Option<HashSet<VtxoId>>,
	all_inputs: HashMap<VtxoId, Vtxo>,
	all_outputs: Vec<VtxoParticipant>,
	/// Keep track of which input vtxos belong to which inputs.
	inputs_per_cosigner: HashMap<PublicKey, Vec<VtxoId>>,
	interactive_participants: HashMap<UnlockHash, InteractiveParticipation>,

	common_round_tx_input: Option<WalletUtxoGuard>,

	round_step: TimedRoundStep,

	proceed: bool,
}

impl CollectingPayments {
	fn new(
		round_seq: RoundSeq,
		attempt_seq: usize,
		round_data: RoundData,
		locked_inputs: OwnedVtxoFluxGuard,
		allowed_inputs: Option<HashSet<VtxoId>>,
		common_round_tx_input: Option<WalletUtxoGuard>,
	) -> CollectingPayments {
		CollectingPayments {
			round_data,
			round_attempt_challenge: RoundAttemptChallenge::generate(),
			locked_inputs,
			allowed_inputs,

			// Generate a one-time use signing key.
			cosign_key: Keypair::new(&SECP, &mut rand::thread_rng()),

			all_inputs: HashMap::new(),
			all_outputs: Vec::new(),
			inputs_per_cosigner: HashMap::new(),
			interactive_participants: HashMap::new(),

			common_round_tx_input,
			round_step: RoundStep::AttemptInitiation.with_instant(round_seq, attempt_seq),
			proceed: false,
		}
	}

	fn first_attempt(&self) -> bool {
		assert_eq!(self.round_step.attempt_seq() == 0, self.allowed_inputs.is_none());
		self.round_step.attempt_seq() == 0
	}

	/// Returns whether there are no valid inputs left in the round
	/// and we need to start a new round.
	fn need_new_round(&self) -> bool {
		!self.first_attempt() && self.allowed_inputs.as_ref().unwrap().is_empty()
	}

	fn have_payments(&self) -> bool {
		!self.all_inputs.is_empty() && (!self.all_outputs.is_empty())
	}

	fn attempt_seq(&self) -> usize {
		self.round_step.attempt_seq()
	}

	fn next_step(&mut self, step: RoundStep) -> TimedRoundStep {
		self.round_step = self.round_step.proceed(step);
		self.round_step
	}

	fn validate_payment_amounts(
		&self,
		inputs: &[Vtxo],
		outputs: impl IntoIterator<Item = impl AsRef<VtxoRequest>>,
	) -> anyhow::Result<()> {
		let mut in_set = HashSet::with_capacity(inputs.len());
		let mut in_sum = Amount::ZERO;
		for input in inputs {
			in_sum += input.amount();
			if in_sum > Amount::MAX_MONEY{
				return badarg!("total input amount overflow");
			}
			if !in_set.insert(input.id()) {
				return badarg!("duplicate input");
			}
		}

		let mut out_sum = Amount::ZERO;
		for output in outputs {
			let output = output.as_ref();

			if output.amount < P2TR_DUST {
				return badarg!("vtxo amount must be at least {}", P2TR_DUST);
			}

			match output.policy {
				// HTLCs are not included in the sum because they don't spend any
				// round input. Instead, they are funded by provided the payment
				// hash and handled in the `collect_htlcs` method.
				VtxoPolicy::ServerHtlcRecv { .. } => {
					continue;
				},
				VtxoPolicy::ServerHtlcSend { .. } => {
					return badarg!("invalid vtxo policy: {:?}", output.policy);
				},
				VtxoPolicy::Pubkey { .. } => {
					out_sum += output.amount;
				},
				VtxoPolicy::Checkpoint { .. } => {
					// Users shouldn't request a VTXO that is owned by the server
					return badarg!("invalid vtxo policy: {:?}", output.policy);
				}
			}

			if out_sum > in_sum {
				return badarg!("total output amount ({out_sum}) exceeds total input amount ({in_sum})");
			}
		}

		Ok(())
	}

	/// This methods does checks on the user input that can be done fast and without
	/// the need to fetch the input vtxos.
	fn validate_payment_data(
		&self,
		inputs: &[VtxoIdInput],
		outputs: impl IntoIterator<Item = impl Borrow<SignedVtxoRequest>>,
	) -> anyhow::Result<()> {
		let mut nb_outputs = 0;
		for output in outputs {
			let output = output.borrow();
			nb_outputs += 1;

			if output.nonces.len() != self.round_data.nb_vtxo_nonces {
				client_rslog!(RoundUserBadNbNonces, self.round_step,
					nb_cosign_nonces: output.nonces.len(),
				);
				bail!("incorrect number of cosign nonces per set");
			}

			if self.inputs_per_cosigner.contains_key(&output.cosign_pubkey) {
				client_rslog!(RoundUserDuplicateCosignPubkey, self.round_step,
					cosign_pubkey: output.cosign_pubkey,
				);
				bail!("duplicate cosign key {}", output.cosign_pubkey);
			}

			if let Some(max) = self.round_data.max_vtxo_amount {
				if output.vtxo.amount > max {
					client_rslog!(RoundUserBadOutputAmount, self.round_step,
						amount: output.vtxo.amount,
					);
					return badarg!("output exceeds maximum vtxo amount of {max}");
				}
			}
		}


		if self.all_outputs.len() + nb_outputs > self.round_data.max_output_vtxos {
			warn!("Got payment we don't have space for, dropping");
			server_rslog!(FullRound, self.round_step,
				nb_outputs: self.all_outputs.len(),
				max_output_vtxos: self.round_data.max_output_vtxos,
			);
			bail!("not enough outputs left in this round, try next round");
		}

		let mut unique_inputs = HashSet::with_capacity(inputs.len());
		for input in inputs {
			if !unique_inputs.insert(input) {
				client_rslog!(RoundUserVtxoDuplicateInput, self.round_step,
					vtxo: input.vtxo_id,
				);
				bail!("user provided duplicate inputs");
			}
			if self.all_inputs.contains_key(&input.vtxo_id) {
				client_rslog!(RoundUserVtxoAlreadyRegistered, self.round_step,
					vtxo: input.vtxo_id,
				);
				bail!("vtxo {} already registered", input.vtxo_id);
			}
		}

		if let Some(ref allowed) = self.allowed_inputs {
			// This means we're not trying first time and we filter inputs.
			if let Some(bad) = inputs.iter().find(|i| !allowed.contains(&i.vtxo_id)) {
				client_rslog!(RoundUserVtxoNotAllowed, self.round_step,
					vtxo: bad.vtxo_id,
				);
				bail!("input vtxo {} has been banned for this round", bad.vtxo_id);
			}
		}

		Ok(())
	}

	/// Fetch and check whether the vtxos are owned by user and
	/// weren't already spent, then return them.
	///
	/// There is no guarantee that the vtxos is still all unspent by
	/// the time this call returns. The caller should ensure no changes
	/// are made to them meanwhile.
	async fn check_fetch_round_input_vtxos(
		&self,
		srv: &Server,
		inputs: &[VtxoId],
	) -> anyhow::Result<Vec<Vtxo>> {
		let mut ret  = Vec::with_capacity(inputs.len());
		match srv.db.get_vtxos_by_id(&inputs).await {
			Ok(vtxos) => {
				// Check if the input vtxos exist, unspent and owned by user.
				for v in vtxos {
					if !v.is_spendable() {
						trace!("trying to submit unspendable vtxo to round: {:?}", v);
						bail!("vtxo {} is not spendable", v.vtxo_id)
					}
					ret.push(v.vtxo);
				}
				Ok(ret)
			},
			Err(e) => {
				if let Some(nf) = e.downcast_ref::<NotFound>() {
					for id in nf.identifiers() {
						client_rslog!(RoundUserVtxoUnknown, self.round_step,
							vtxo: Some(VtxoId::from_str(id).expect("should be a valid vtxoid")),
						);
					}
				}
				Err(e)
			},
		}
	}

	fn register_interactive_participation(
		&mut self,
		flux_guard: VtxoFluxGuard,
		inputs: Vec<Vtxo>,
		vtxo_requests: Vec<SignedVtxoRequest>,
		unlock_preimage: UnlockPreimage,
	) {
		let unlock_hash = sha256::Hash::hash(&unlock_preimage);
		client_rslog!(RoundPaymentRegistered, self.round_step, unlock_hash,
			nb_inputs: inputs.len(),
			nb_outputs: vtxo_requests.len(),
		);

		// If we're adding inputs for the first time, also add them to locked_inputs.
		if self.first_attempt() {
			self.locked_inputs.absorb(flux_guard);
		}

		let input_ids = inputs.iter().map(|v| v.id()).collect::<Vec<_>>();
		self.all_inputs.extend(inputs.into_iter().map(|v| (v.id(), v)));

		self.inputs_per_cosigner.reserve(vtxo_requests.len());
		for req in &vtxo_requests {
			assert!(
				self.inputs_per_cosigner.insert(req.cosign_pubkey, input_ids.clone()).is_none(),
				"should be checked before",
			);

			self.all_outputs.push(VtxoParticipant::new_signed(req.clone(), unlock_hash));
		}

		assert!(self.interactive_participants.insert(unlock_hash, InteractiveParticipation {
			unlock_preimage: unlock_preimage,
			inputs: input_ids,
			outputs: vtxo_requests.into_iter().map(|r| r.vtxo).collect(),
		}).is_none(), "duplicate unlock hash");

		// Check whether our round is full.
		if self.all_outputs.len() == self.round_data.max_output_vtxos {
			server_rslog!(FullRound, self.round_step,
				nb_outputs: self.all_outputs.len(),
				max_output_vtxos: self.round_data.max_output_vtxos,
			);
			self.proceed = true;
		}
	}

	fn register_non_interactive_participation(
		&mut self,
		flux_guard: VtxoFluxGuard,
		inputs: Vec<Vtxo>,
		vtxo_requests: Vec<VtxoRequest>,
		unlock_hash: UnlockHash,
	) {
		client_rslog!(RoundPaymentRegistered, self.round_step, unlock_hash,
			nb_inputs: inputs.len(),
			nb_outputs: vtxo_requests.len(),
		);

		// If we're adding inputs for the first time, also add them to locked_inputs.
		if self.first_attempt() {
			self.locked_inputs.absorb(flux_guard);
		}

		self.all_inputs.extend(inputs.into_iter().map(|v| (v.id(), v)));

		for req in vtxo_requests {
			self.all_outputs.push(VtxoParticipant::new_non_interactive(req, unlock_hash));
		}

		// Check whether our round is full.
		if self.all_outputs.len() == self.round_data.max_output_vtxos {
			server_rslog!(FullRound, self.round_step,
				nb_outputs: self.all_outputs.len(),
				max_output_vtxos: self.round_data.max_output_vtxos,
			);
			self.proceed = true;
		}
	}

	pub async fn process_payment(
		&mut self,
		srv: &Server,
		inputs: Vec<VtxoIdInput>,
		vtxo_requests: Vec<SignedVtxoRequest>,
		unlock_preimage: UnlockPreimage,
	) -> anyhow::Result<()> {
		if vtxo_requests.is_empty() {
			return badarg!("invalid request: no outputs");
		}

		self.validate_payment_data(&inputs, &vtxo_requests)?;

		let input_ids = inputs.iter().map(|i| i.vtxo_id).collect::<Vec<_>>();
		let flux_guard = srv.vtxos_in_flux.lock(&input_ids)
			.map_err(|e| { client_rslog!(RoundUserVtxoInFlux, self.round_step, vtxo: e.id); e })
			.badarg("input VTXO already locked")?;

		// Check if the input vtxos exist and are unspent.
		let input_vtxos = match self.check_fetch_round_input_vtxos(srv, &input_ids).await {
			Ok(i) => i,
			Err(e) => {
				let ret = if let Some(id) = e.downcast_ref::<VtxoId>().cloned() {
					client_rslog!(RoundUserVtxoUnknown, self.round_step,
						vtxo: Some(id),
					);
					Err(e).not_found([id], "input vtxo does not exist")
				} else {
					Err(e)
				};
				return ret;
			}
		};


		let ownership_proof_by_vtxo_id = inputs.iter()
			.map(|v| (v.vtxo_id, &v.ownership_proof))
			.collect::<HashMap<_,_>>();
		for input in &input_vtxos {
			let sig = ownership_proof_by_vtxo_id.get(&input.id()).expect("all vtxos were found");
			self.round_attempt_challenge.verify_input_vtxo_sig(input, &vtxo_requests, sig)
				.with_context(|| format!(
					"ownership proof is invalid: vtxo {}, proof: {}", input.id(), sig,
				))?;
		}

		if let Err(e) = self.validate_payment_amounts(&input_vtxos, &vtxo_requests) {
			client_rslog!(RoundPaymentRegistrationFailed, self.round_step,
				error: e.to_string(),
			);
			return Err(e).context("amounts check failed");
		}

		if let Err(e) = srv.check_vtxos_not_exited(&input_vtxos).await {
			client_rslog!(RoundPaymentRegistrationFailed, self.round_step,
				error: e.to_string(),
			);
			return Err(e).context("some vtxo was already exited");
		}

		// Finally, we are done
		self.register_interactive_participation(flux_guard, input_vtxos, vtxo_requests, unlock_preimage);

		Ok(())
	}

	async fn process_non_interactive_participation(
		&mut self,
		srv: &Server,
		participation: StoredRoundParticipation,
	) -> Result<(), ProcessHarkParticipationError> {
		if participation.outputs.is_empty() {
			return Err(ProcessHarkParticipationError::BadParticipation(
				anyhow!("invalid request: no outputs")
			));
		}

		for output in &participation.outputs {
			if let Some(max) = self.round_data.max_vtxo_amount {
				if output.amount > max {
					client_rslog!(RoundUserBadOutputAmount, self.round_step,
						amount: output.amount,
					);
					return Err(ProcessHarkParticipationError::BadParticipation(
						anyhow!("output exceeds maximum vtxo amount of {max}")
					));
				}
			}
		}

		let nb_outputs = participation.outputs.len();
		if self.all_outputs.len() + nb_outputs > self.round_data.max_output_vtxos {
			warn!("Got payment we don't have space for, dropping");
			server_rslog!(FullRound, self.round_step,
				nb_outputs: self.all_outputs.len(),
				max_output_vtxos: self.round_data.max_output_vtxos,
			);
			return Err(ProcessHarkParticipationError::RoundFull);
		}

		let input_ids = participation.inputs.iter().map(|i| i.vtxo_id).collect::<Vec<_>>();
		let lock = match srv.vtxos_in_flux.lock(&input_ids) {
			Ok(l) => l,
			Err(e) => {
				client_rslog!(RoundUserVtxoInFlux, self.round_step,
					vtxo: e.id,
				);
				return Err(ProcessHarkParticipationError::BadParticipation(
					badarg_err!("VTXO already in use by another process: {e}")
				));
			},
		};

		for input in &participation.inputs {
			if self.all_inputs.contains_key(&input.vtxo_id) {
				client_rslog!(RoundUserVtxoAlreadyRegistered, self.round_step,
					vtxo: input.vtxo_id,
				);
				return Err(ProcessHarkParticipationError::BadParticipation(
					anyhow!("vtxo {} already registered", input.vtxo_id)
				));
			}
		}

		if let Some(ref allowed) = self.allowed_inputs {
			// This means we're not trying first time and we filter inputs.
			if let Some(bad) = input_ids.iter().find(|i| !allowed.contains(&i)) {
				client_rslog!(RoundUserVtxoNotAllowed, self.round_step, vtxo: *bad);
				return Err(ProcessHarkParticipationError::BadParticipation(
					anyhow!("input vtxo {} has been banned for this round", bad)
				));
			}
		}

		// Check if the input vtxos exist and are unspent.
		let input_vtxos = match self.check_fetch_round_input_vtxos(srv, &input_ids).await {
			Ok(i) => i,
			Err(e) => return Err(ProcessHarkParticipationError::BadParticipation(e)),
		};

		if let Err(e) = self.validate_payment_amounts(&input_vtxos, participation.outputs.iter()) {
			client_rslog!(RoundPaymentRegistrationFailed, self.round_step,
				error: e.to_string(),
			);
			return Err(ProcessHarkParticipationError::BadParticipation(
				e.context("amount  check failed"),
			));
		}

		if let Err(e) = srv.check_vtxos_not_exited(&input_vtxos).await {
			client_rslog!(RoundPaymentRegistrationFailed, self.round_step,
				error: e.to_string(),
			);
			return Err(ProcessHarkParticipationError::BadParticipation(
				e.context("some vtxo was already exited"),
			));
		}

		// Finally, we are done
		self.register_non_interactive_participation(
			lock,
			input_vtxos,
			participation.outputs,
			participation.unlock_hash,
		);

		Ok(())
	}

	pub async fn register_all_non_interactive_participations(
		&mut self,
		srv: &Server,
	) {
		//TODO(stevenroose) do this streamingly to avoid allocation
		let parts = match srv.db.get_all_pending_round_participations().await {
			Ok(p) => p,
			Err(e) => {
				error!("Error loading pending hArk participations: {}", e);
				return;
			},
		};

		for part in parts {
			let unlock_hash = part.unlock_hash;
			if self.interactive_participants.contains_key(&unlock_hash) {
				error!(unlock_hash = unlock_hash.to_string();
					"A hark participation for an unlock hash we just created, \
					might mean we don't protect hArk participants during round!");
				continue;
			}
			match self.process_non_interactive_participation(srv, part).await {
				Ok(()) => {},
				// NB we already slog this when producing error
				Err(ProcessHarkParticipationError::RoundFull) => continue,
				Err(ProcessHarkParticipationError::BadParticipation(e)) => {
					slog!(RoundParticipationRejected, unlock_hash, reason: format!("{:#}", e));

					match srv.db.remove_round_participation(unlock_hash).await {
						Err(e) => warn!("Error removing hArk round participation for \
							unlock hash {}: {:#}", unlock_hash, e),
						Ok(false) => warn!("Couldn't removing hArk round participation for \
							unlock hash {}: no longer there", unlock_hash),
						Ok(true) => {},
					}

					continue;
				},
			}

			if self.proceed {
				// NB we already slog for this
				break;
			}
		}
	}

	async fn progress(mut self, srv: &Server) -> Result<SigningVtxoTree, RoundError> {
		let tip = srv.chain_tip().height;
		let expiry_height = tip + srv.config.vtxo_lifetime as BlockHeight;

		let round_step = self.next_step(RoundStep::ConstructVtxoTree);
		let mut span = trace_round_step(&round_step);
		span.set_int_attr("expiry_height", expiry_height);
		span.set_int_attr("block_height", tip);

		// In later versions, it is very likely that the server
		// will actually want to create change vtxos, so temporarily, this
		// dummy vtxo will be a placeholder for a potential change vtxo.
		// In fact, because leaves now have different outputs than leaves,
		// the single-output case is also annoying, so we require at least two.
		while self.all_outputs.len() <= 1 {
			lazy_static::lazy_static! {
				/// Unspendable pubkey
				/// 0x02 ++ sha256("unspendable1")
				static ref UNSPENDABLE: PublicKey =
					"02dfa52f6690299d2d6a08323083e290597b56fee125063e5f4e2957731639c42c".parse().unwrap();
				/// hash without known preimage
				static ref UNLOCK_HASH: sha256::Hash =
					"deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef".parse().unwrap();
			}
			let req = VtxoLeafSpec {
				vtxo: VtxoRequest {
					policy: VtxoPolicy::new_pubkey(*UNSPENDABLE),
					amount: P2WSH_DUST,
				},
				cosign_pubkey: None,
				unlock_hash: *UNLOCK_HASH,
			};
			self.all_outputs.push(VtxoParticipant {
				req: req.clone(),
				nonces: None,
			});
		}

		let vtxos_spec = VtxoTreeSpec::new(
			self.all_outputs.iter().map(|p| p.req.clone()).collect(),
			srv.server_pubkey,
			expiry_height,
			srv.config.vtxo_exit_delta,
			vec![self.cosign_key.public_key()],
		);

		// Build round tx.
		//TODO(stevenroose) think about if we can release lock sooner
		let trusted_height = match srv.config.round_tx_untrusted_input_confirmations {
			0 => None,
			n => Some(tip.saturating_sub(n as BlockHeight - 1)),
		};
		let mut wallet_lock = srv.rounds_wallet.clone().lock_owned().await;
		let round_tx_psbt = {
			let unavailable = wallet_lock.unavailable_outputs(trusted_height);
			let mut b = wallet_lock.build_tx();
			b.ordering(bdk_wallet::TxOrdering::Untouched);
			b.current_height(tip);
			b.unspendable(unavailable);
			// NB: manual selection overrides unspendable
			if let Some(ref common_round_tx_input) = self.common_round_tx_input {
				let utxo = common_round_tx_input.utxo().clone();
				b.add_utxo(utxo).map_err(|e| RoundError::Recoverable(e.into()))?;
			}
			// NB: order is important here, we need to respect `ROUND_TX_VTXO_TREE_VOUT`
			b.add_recipient(vtxos_spec.funding_tx_script_pubkey(), vtxos_spec.total_required_value());
			b.fee_rate(srv.config.round_tx_feerate);
			match b.finish().context("bdk failed to create round tx") {
				Ok(psbt) => psbt,
				Err(e) => return Err(RoundError::Recoverable(e)),
			}
		};
		let res = round_tx_psbt.clone().extract_tx().context("failed to extract tx from psbt");
		let unsigned_round_tx = match res {
			Ok(tx) => tx,
			Err(e) => return Err(RoundError::Recoverable(e)),
		};

		let common_round_tx_input = match self.common_round_tx_input {
			Some(ref input) => input.clone(),
			None => {
				let common_round_tx_input = unsigned_round_tx.input.first()
					.expect("funded round tx should have an input").previous_output;
				wallet_lock.lock_wallet_utxo(common_round_tx_input)
					.map_err(|e| RoundError::Recoverable(e.into()))?
			}
		};

		let round_txid = unsigned_round_tx.compute_txid();
		let vtxos_utxo = OutPoint::new(round_txid, ROUND_TX_VTXO_TREE_VOUT);

		// Generate vtxo nonces and combine with user's nonces.
		let (cosign_sec_nonces, cosign_pub_nonces) = {
			let nb_internal = vtxos_spec.nb_internal_nodes();
			let mut secs = Vec::with_capacity(nb_internal);
			let mut pubs = Vec::with_capacity(nb_internal);
			for _ in 0..nb_internal {
				let (s, p) = musig::nonce_pair(&self.cosign_key);
				secs.push(s);
				pubs.push(p);
			}
			(secs, pubs)
		};
		let user_cosign_nonces = self.all_outputs.iter()
			.filter_map(|r| {
				r.req.cosign_pubkey
					.map(|pk| (pk, r.nonces.clone().expect("can't have cosign pk but no nonces")))
			})
			.collect::<HashMap<_, _>>();
		let res = vtxos_spec.calculate_cosign_agg_nonces(
			&user_cosign_nonces, &[&cosign_pub_nonces],
		);
		let cosign_agg_nonces = match res {
			Ok(n) => n,
			Err(e) => return Err(RoundError::Recoverable(anyhow!(
				"error calculating cosign agg nonces: {}", e,
			))),
		};

		server_rslog!(ConstructingRoundVtxoTree, round_step,
			tip_block_height: tip,
			vtxo_expiry_block_height: expiry_height,
		);
		telemetry::set_round_step_duration(round_step);

		let round_step = self.next_step(RoundStep::SendingVtxoProposal);
		let _span = trace_round_step(&round_step);

		// Send out a vtxo proposal to signers.
		srv.rounds.broadcast_event(RoundEvent::VtxoProposal(VtxoProposal {
			round_seq: round_step.round_seq(),
			attempt_seq: round_step.attempt_seq(),
			unsigned_round_tx: unsigned_round_tx.clone(),
			vtxos_spec: vtxos_spec.clone(),
			cosign_agg_nonces: cosign_agg_nonces.clone(),
		}));

		let unsigned_vtxo_tree = vtxos_spec.into_unsigned_tree(vtxos_utxo);
		// proceed if no leaves need cosigning
		let proceed = unsigned_vtxo_tree.nb_cosigned_leaves() == 0;

		server_rslog!(SendVtxoProposal, round_step);
		telemetry::set_round_step_duration(round_step);

		Ok(SigningVtxoTree {
			round_data: self.round_data,
			expiry_height,
			cosign_key: self.cosign_key,
			cosign_sec_nonces,
			cosign_pub_nonces,
			cosign_agg_nonces,
			all_inputs: self.all_inputs,
			locked_inputs: self.locked_inputs,
			interactive_participants: self.interactive_participants,
			cosign_part_sigs: HashMap::with_capacity(unsigned_vtxo_tree.nb_leaves()),
			unsigned_vtxo_tree,
			wallet_lock,
			round_tx_psbt,
			round_txid,
			user_cosign_nonces,
			inputs_per_cosigner: self.inputs_per_cosigner,
			common_round_tx_input,
			round_step,
			proceed,
		})
	}

	fn total_input_amount(&self) -> Amount {
		self.all_inputs.values()
			.map(|vtxo| vtxo.amount())
			.sum()
	}
}

enum ProcessHarkParticipationError {
	RoundFull,
	BadParticipation(anyhow::Error),
}

pub struct SigningVtxoTree {
	round_data: RoundData,
	expiry_height: BlockHeight,

	cosign_key: Keypair,
	cosign_sec_nonces: Vec<SecretNonce>,
	cosign_pub_nonces: Vec<PublicNonce>,
	cosign_part_sigs: HashMap<PublicKey, Vec<musig::PartialSignature>>,
	cosign_agg_nonces: Vec<musig::AggregatedNonce>,
	unsigned_vtxo_tree: UnsignedVtxoTree,
	wallet_lock: OwnedMutexGuard<PersistedWallet>,
	round_tx_psbt: Psbt,
	round_txid: Txid,

	// data from earlier
	all_inputs: HashMap<VtxoId, Vtxo>,
	user_cosign_nonces: HashMap<PublicKey, Vec<musig::PublicNonce>>,
	inputs_per_cosigner: HashMap<PublicKey, Vec<VtxoId>>,
	/// All inputs that have participated, but might have dropped out.
	locked_inputs: OwnedVtxoFluxGuard,
	interactive_participants: HashMap<UnlockHash, InteractiveParticipation>,

	common_round_tx_input: WalletUtxoGuard,

	round_step: TimedRoundStep,

	proceed: bool,
}

impl SigningVtxoTree {
	fn next_step(&mut self, step: RoundStep) -> TimedRoundStep {
		self.round_step = self.round_step.proceed(step);
		self.round_step
	}

	pub fn register_signature(
		&mut self,
		pubkey: PublicKey,
		signatures: Vec<musig::PartialSignature>,
	) -> anyhow::Result<()> {
		// Check for duplicates.
		if self.cosign_part_sigs.contains_key(&pubkey) {
			trace!("User with pubkey {} submitted partial vtxo sigs again", pubkey);
			return badarg!("duplicate signatures for pubkey");
		}

		let req = match self.unsigned_vtxo_tree.spec.vtxos.iter()
			.find(|v| v.cosign_pubkey == Some(pubkey))
		{
			Some(r) => r,
			None => {
				trace!("Received signatures from non-signer: {}", pubkey);
				return badarg!("pubkey is not part of cosigner group");
			},
		};
		client_rslog!(RoundVtxoSignaturesRegistered, self.round_step,
			nb_vtxo_signatures: signatures.len(),
			cosigner: pubkey,
		);

		let res = self.unsigned_vtxo_tree.verify_branch_cosign_partial_sigs(
			&self.cosign_agg_nonces,
			req,
			&self.user_cosign_nonces.get(&pubkey).expect("vtxo part of round"),
			&signatures,
		);
		if let Err(e) = res {
			debug!("Received invalid partial vtxo sigs from signer: {}: {}", pubkey, e);
			return badarg!("invalid partial signatures: {}", e);
		}

		self.cosign_part_sigs.insert(pubkey, signatures);

		// Stop the loop once we have all.
		if self.cosign_part_sigs.len() == self.unsigned_vtxo_tree.nb_cosigned_leaves() {
			self.proceed = true;
		}
		Ok(())
	}

	fn restart(self) -> CollectingPayments {
		let mut allowed_inputs = self.all_inputs.keys().copied().collect::<HashSet<_>>();
		for (pk, vtxos) in self.inputs_per_cosigner.iter() {
			if !self.cosign_part_sigs.contains_key(pk) {
				// Disallow all inputs by this cosigner.
				server_rslog!(DroppingLateVtxoSignatureVtxos, self.round_step,
					disallowed_vtxos: vtxos.clone(),
				);
				for id in vtxos {
					allowed_inputs.remove(id);
				}
			}
		}
		CollectingPayments::new(
			self.round_step.round_seq(),
			self.round_step.attempt_seq() + 1,
			self.round_data,
			self.locked_inputs,
			Some(allowed_inputs),
			Some(self.common_round_tx_input),
		)
	}

	async fn finish(mut self, srv: &Server) -> Result<(), RoundError> {
		// Combine the vtxo signatures.
		let round_step = self.next_step(RoundStep::CombineVtxoSignatures);
		let _span = trace_round_step(&round_step);

		let srv_cosign_sigs = self.unsigned_vtxo_tree.cosign_tree(
			&self.cosign_agg_nonces,
			&self.cosign_key,
			mem::replace(&mut self.cosign_sec_nonces, Vec::new()),
		);
		debug_assert_eq!(self.unsigned_vtxo_tree.verify_global_cosign_partial_sigs(
			self.cosign_key.public_key(),
			&self.cosign_agg_nonces,
			&self.cosign_pub_nonces,
			&srv_cosign_sigs,
		), Ok(()));
		let cosign_sigs = self.unsigned_vtxo_tree.combine_partial_signatures(
			&self.cosign_agg_nonces,
			&self.cosign_part_sigs,
			&[&srv_cosign_sigs],
		).expect("failed to combine partial vtxo cosign signatures: should have checked partials");
		debug_assert_eq!(self.unsigned_vtxo_tree.verify_cosign_sigs(&cosign_sigs), Ok(()));

		// Then construct the final signed vtxo tree.
		let round_step = self.next_step(RoundStep::SignOnChainTransaction);
		let signed_vtxos = self.unsigned_vtxo_tree
			.into_signed_tree(cosign_sigs)
			.into_cached_tree();

		// ****************************************************************
		// * Broadcast signed vtxo tree and round funding tx
		// ****************************************************************

		server_rslog!(CreatedSignedVtxoTree, round_step,
			nb_vtxo_signatures: signed_vtxos.spec.cosign_sigs.len(),
		);
		telemetry::set_round_step_duration(round_step);

		// Sign the on-chain tx.
		let signed_round_tx = match self.wallet_lock.finish_tx(self.round_tx_psbt) {
			Ok(tx) => tx,
			Err(e) => return Err(RoundError::Recoverable(e.context("round tx signing error"))),
		};
		self.wallet_lock.commit_tx(&signed_round_tx);
		if let Err(e) = self.wallet_lock.persist().await {
			// Failing to persist the tx data at this point means that we might
			// accidentally re-use certain inputs if we reboot the server.
			// We keep the change set in the wallet if this happens.
			warn!("Failed to persist BDK wallet to db: {:?}", e);
		}

		drop(self.wallet_lock); // we no longer need the lock
		let signed_round_tx = srv.tx_nursery.broadcast_tx(signed_round_tx).await
			.map_err(|err| RoundError::Fatal(err.context("failed to broadcast round")))?;

		// Send out the finished round to users.
		trace!("Sending out finish event.");
		srv.rounds.broadcast_event(RoundEvent::Finished(RoundFinished {
			round_seq: round_step.round_seq(),
			attempt_seq: round_step.attempt_seq(),
			cosign_sigs: signed_vtxos.spec.cosign_sigs.clone(),
			signed_round_tx: signed_round_tx.tx.clone(),
		}));

		server_rslog!(BroadcastedFinalizedRoundTransaction, round_step,
			txid: self.round_txid,
		);
		telemetry::set_round_step_duration(round_step);

		let round_step = round_step.proceed(RoundStep::Persist);
		let mut span = trace_round_step(&round_step);
		span.set_int_attr("signed_vtxo_count", signed_vtxos.nb_leaves());
		span.set_str_attr(telemetry::ATTRIBUTE_ROUND_ID, self.round_txid);

		trace!("Storing round result");
		if log_enabled!(RoundVtxoCreated::LEVEL) {
			for vtxo in signed_vtxos.all_vtxos() {
				server_rslog!(RoundVtxoCreated, round_step,
					vtxo_id: vtxo.id(),
					vtxo_type: vtxo.policy().policy_type(),
				);
			}
		}
		let result = srv.db.finish_round(
			round_step.round_seq(),
			&signed_round_tx.tx,
			self.all_inputs.keys().copied(),
			&signed_vtxos,
			&self.interactive_participants,
		).await;
		telemetry::set_round_step_duration(round_step);
		if let Err(e) = result {
			server_rslog!(FatalStoringRound, round_step,
				error: format!("{:?}", e),
				signed_tx: serialize(&signed_round_tx.tx),
				vtxo_tree: signed_vtxos.spec.serialize(),
				input_vtxos: self.all_inputs.keys().copied().collect(),
			);
			return Err(RoundError::Fatal(e));
		}

		server_rslog!(RoundFinished, round_step,
			txid: self.round_txid,
			vtxo_expiry_block_height: self.expiry_height,
			nb_input_vtxos: self.all_inputs.len(),
		);

		Ok(())
	}
}

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub enum RoundStateKind {
	/// see [`CollectingPayments`]
	CollectingPayments,
	/// see [`SigningVtxoTree`]
	SigningVtxoTree,
	FinishedEmpty,
	FinishedAbandoned,
	FinishedSuccess,
	FinishedError,
}

impl RoundStateKind {
	pub fn as_str(&self) -> &'static str {
		match self {
			RoundStateKind::CollectingPayments => "CollectingPayments",
			RoundStateKind::SigningVtxoTree => "SigningVtxoTree",
			RoundStateKind::FinishedEmpty => "FinishedEmpty",
			RoundStateKind::FinishedAbandoned => "FinishedAbandoned",
			RoundStateKind::FinishedSuccess => "FinishedSuccess",
			RoundStateKind::FinishedError => "FinishedError",
		}
	}
	pub fn get_all() -> &'static [RoundStateKind] {
		&[
			RoundStateKind::CollectingPayments,
			RoundStateKind::SigningVtxoTree,
			RoundStateKind::FinishedEmpty,
			RoundStateKind::FinishedAbandoned,
			RoundStateKind::FinishedSuccess,
			RoundStateKind::FinishedError,
		]
	}
}

enum RoundState {
	CollectingPayments(CollectingPayments),
	SigningVtxoTree(SigningVtxoTree),
	Finished(RoundResult),
}

impl RoundState {
	fn kind(&self) -> RoundStateKind {
		match &self {
			Self::CollectingPayments(_) => RoundStateKind::CollectingPayments,
			Self::SigningVtxoTree(_) => RoundStateKind::SigningVtxoTree,
			Self::Finished(result) => {
				match result {
					RoundResult::Empty => RoundStateKind::FinishedEmpty,
					RoundResult::Abandoned => RoundStateKind::FinishedAbandoned,
					RoundResult::Success => RoundStateKind::FinishedSuccess,
					RoundResult::Err(_) => RoundStateKind::FinishedError,
				}
			}
		}
	}

	fn proceed(&self) -> bool {
		match self {
			Self::CollectingPayments(s) => s.proceed,
			Self::SigningVtxoTree(s) => s.proceed,
			Self::Finished(_) => false,
		}
	}

	fn collecting_payments(&mut self) -> &mut CollectingPayments {
		match self {
			RoundState::CollectingPayments(s) => s,
			_ => panic!("wrong state"),
		}
	}

	fn into_collecting_payments(self) -> CollectingPayments {
		match self {
			RoundState::CollectingPayments(s) => s,
			_ => panic!("wrong state"),
		}
	}

	fn signing_vtxo_tree(&mut self) -> &mut SigningVtxoTree {
		match self {
			RoundState::SigningVtxoTree(s) => s,
			_ => panic!("wrong state"),
		}
	}

	fn into_signing_vtxo_tree(self) -> SigningVtxoTree {
		match self {
			RoundState::SigningVtxoTree(s) => s,
			_ => panic!("wrong state"),
		}
	}

	fn into_finished(self, result: RoundResult) -> Self {
		match self {
			RoundState::CollectingPayments(_)
			| RoundState::SigningVtxoTree(_) => RoundState::Finished(result),
			_ => panic!("wrong state"),
		}
	}

	fn result(self) -> Option<RoundResult> {
		match self {
			RoundState::CollectingPayments(_)
			| RoundState::SigningVtxoTree(_) => None,
			RoundState::Finished(result) => Some(result),
		}
	}
}

#[derive(Debug)]
enum RoundError {
	/// An error occurred, but we can just restart.
	Recoverable(anyhow::Error),
	/// A fatal error occurred that we can't recover from. Halt operations.
	Fatal(anyhow::Error),
}

#[derive(Debug)]
enum RoundResult {
	/// Nothing to do, skipping round.
	Empty,
	/// All users abandoned the round.
	Abandoned,
	/// Round finished with success.
	Success,
	/// Error.
	Err(RoundError),
}

impl From<RoundError> for RoundResult {
	fn from(e: RoundError) -> Self {
		Self::Err(e)
	}
}

async fn perform_round(
	srv: &Arc<Server>,
	round_input_rx: &mut mpsc::UnboundedReceiver<(RoundInput, oneshot::Sender<anyhow::Error>)>,
	round_seq: RoundSeq,
) -> RoundResult {
	let tracer_provider = global::tracer_provider().tracer(telemetry::Captaind::TRACER);

	let mut span = tracer_provider
		.span_builder(telemetry::TRACE_RUN_ROUND)
		.with_kind(SpanKind::Server)
		.start(&tracer_provider);
	span.set_int_attr(telemetry::ATTRIBUTE_ROUND_SEQ, round_seq.inner());

	let parent_context = opentelemetry::Context::current_with_span(span);

	let tracing_span = info_span!(telemetry::TRACE_RUN_ROUND);
	let _ = tracing_span.set_parent(parent_context.clone())
		.map_err(|e| error!("error setting tracing span ctx parent: {}", e));

	// this is to make sure slog has access to the span information.
	let _guard = tracing_span.enter();

	slog!(RoundStarted, round_seq);
	telemetry::set_round_seq(round_seq);

	let round_data = RoundData {
		// The maximum number of output vtxos per round based on the max number
		// of vtxo tree nonces we require users to provide.
		//TODO(stevenroose) should probably reverse the config here
		max_output_vtxos: 4_usize.saturating_pow(srv.config.nb_round_nonces as u32),
		nb_vtxo_nonces: srv.config.nb_round_nonces,
		max_vtxo_amount: srv.config.max_vtxo_amount,
	};

	let mut round_state = RoundState::CollectingPayments(CollectingPayments::new(
		round_seq, 0, round_data, srv.vtxos_in_flux.empty_guard().into_owned(), None, None,
	));
	telemetry::set_round_state(round_state.kind());

	// In this loop we will try to finish the round and make new attempts.
	'attempt: loop {
		if let Err(e) = srv.rounds_wallet.lock().await.sync(&srv.bitcoind, false).await {
			slog!(RoundSyncError, error: format!("{:?}", e));
		}

		let state = round_state.collecting_payments();

		// Release all vtxos in flux from a previous attempt
		state.locked_inputs.release_all();

		let mut span = trace_round_step(&state.round_step);
		span.set_bytes_attr("challenge", state.round_attempt_challenge.inner().as_slice());

		telemetry::set_round_attempt(state.attempt_seq());

		srv.rounds.broadcast_event(RoundEvent::Attempt(RoundAttempt {
			round_seq,
			attempt_seq: state.attempt_seq(),
			challenge: state.round_attempt_challenge,
		}));

		server_rslog!(AttemptingRound, state.round_step,
			challenge: state.round_attempt_challenge.inner().to_vec(),
		);
		telemetry::set_round_step_duration(state.round_step);

		// Start receiving payments.
		let round_step = state.next_step(RoundStep::ReceivePayments);
		let _span = trace_round_step(&round_step);

		tokio::pin! { let timeout = tokio::time::sleep(srv.config.round_submit_time); }
		'receive: loop {
			tokio::select! {
				() = &mut timeout => break 'receive,
				input = round_input_rx.recv() => {
					let (input, tx) = input.expect("broken channel");

					let res = match input {
						RoundInput::RegisterPayment { inputs, vtxo_requests, unlock_preimage } => {
							state.process_payment(
								srv, inputs, vtxo_requests, unlock_preimage,
							).await.map_err(|e| {
								debug!("error processing payment: {e}");
								e
							})
						},
						_ => badarg!("unexpected message. current step is payment registration"),
					};

					if let Err(e) = res {
						tx.send(e).expect("broken channel");
						continue 'receive;
					}

					if state.proceed {
						break 'receive;
					}
				}
			}
		}

		// after the interactive sign-ups, also add our non-interactive participations
		state.register_all_non_interactive_participations(srv).await;

		let input_volume = state.total_input_amount();
		let input_count = state.all_inputs.len();
		let output_count = state.all_outputs.len();

		server_rslog!(ReceivedRoundPayments, round_step,
			max_round_submit_time: srv.config.round_submit_time,
			input_volume,
			input_count,
			output_count,
		);
		telemetry::set_round_step_duration(round_step);
		telemetry::set_round_metrics(input_volume, input_count, output_count);

		if !state.have_payments() {
			server_rslog!(NoRoundPayments, round_step,
				max_round_submit_time: srv.config.round_submit_time,
			);

			round_state = round_state.into_finished(RoundResult::Empty);

			telemetry::set_round_state(round_state.kind());

			return round_state.result().unwrap();
		}

		let mut span = tracer_provider
			.span_builder(telemetry::TRACE_RUN_ROUND_POPULATED)
			.with_kind(SpanKind::Internal)
			.start_with_context(&tracer_provider, &parent_context);
		span.set_int_attr(telemetry::ATTRIBUTE_ROUND_SEQ, round_seq.inner());
		span.set_int_attr(telemetry::ATTRIBUTE_ATTEMPT_SEQ, state.attempt_seq());
		span.set_int_attr("input_volume", input_volume.to_sat());
		span.set_int_attr("input_count", input_count);
		span.set_int_attr("output_count", output_count);


		// ****************************************************************
		// * Vtxo tree construction and signing
		// *
		// * - We will always store vtxo tx data from top to bottom,
		// *   meaning from the root tx down to the leaves.
		// ****************************************************************
		round_state = match round_state.into_collecting_payments().progress(srv).await {
			Ok(s) => RoundState::SigningVtxoTree(s),
			Err(e) => return {
				round_state = RoundState::Finished(RoundResult::Err(e));

				telemetry::set_round_state(round_state.kind());

				round_state.result().unwrap()
			},
		};

		// Wait for signatures from users
		let round_step = round_state.signing_vtxo_tree().next_step(RoundStep::ReceiveVtxoSignatures);
		let _span = trace_round_step(&round_step);

		tokio::pin! { let timeout = tokio::time::sleep(srv.config.round_sign_time); }
		'receive: loop {
			if round_state.proceed() {
				break 'receive;
			}
			tokio::select! {
				_ = &mut timeout => {
					warn!("Timed out receiving vtxo partial signatures.");
					server_rslog!(RestartMissingVtxoSigs, round_step);
					let new = round_state.into_signing_vtxo_tree().restart();
					let need_new_round = new.need_new_round();
					round_state = RoundState::CollectingPayments(new);

					if need_new_round {
						server_rslog!(NeedNewRound, round_step,
							max_round_sign_time: srv.config.round_sign_time,
						);

						round_state = round_state.into_finished(RoundResult::Abandoned);

						telemetry::set_round_state(round_state.kind());

						return round_state.result().unwrap();
					}

					continue 'attempt;
				},
				input = round_input_rx.recv() => {
					let state = round_state.signing_vtxo_tree();
					let round_step = state.round_step;
					let (input, tx) = input.expect("broken channel");

					let res = match input {
						RoundInput::VtxoSignatures { pubkey, signatures } => {
							state.register_signature(pubkey, signatures).map_err(|e| {
								client_rslog!(VtxoSignatureRegistrationFailed, round_step,
									error: e.to_string(),
								);
								e
							})
						},
						RoundInput::RegisterPayment { .. } => {
							badarg!("Round already started. \
								Message arrived late or round was full.")
						},
					};

					if let Err(e) = res {
						let _ = tx.send(e);
						continue 'receive;
					}

					if round_state.proceed() {
						break 'receive;
					}
				}
			}
		}

		server_rslog!(ReceivedRoundVtxoSignatures, round_step,
			max_round_sign_time: srv.config.round_sign_time,
		);
		telemetry::set_round_step_duration(round_step);

		// ****************************************************************
		// * Finish the round
		// ****************************************************************

		let round_step = round_state.signing_vtxo_tree().next_step(RoundStep::FinalStage);
		let _span = trace_round_step(&round_step);

		round_state = match round_state.into_signing_vtxo_tree().finish(&srv).await {
			Ok(()) => {
				RoundState::Finished(RoundResult::Success)
			},
			Err(e) => {
				RoundState::Finished(RoundResult::Err(e))
			},
		};

		telemetry::set_round_step_duration(round_step);
		telemetry::set_round_state(round_state.kind());

		return round_state.result().unwrap();
	}
}

fn trace_round_step(round_step: &TimedRoundStep) -> <BoxedTracer as Tracer>::Span {
	let tracer_provider = global::tracer_provider().tracer(telemetry::Captaind::TRACER);
	let parent_context = opentelemetry::Context::current();

	let mut span = tracer_provider
		.span_builder(round_step.as_str())
		.with_kind(SpanKind::Internal)
		.start_with_context(&tracer_provider, &parent_context);
	span.set_int_attr(telemetry::ATTRIBUTE_ROUND_SEQ, round_step.round_seq().inner());
	span.set_int_attr(telemetry::ATTRIBUTE_ATTEMPT_SEQ, round_step.attempt_seq());

	span
}

/// This method is called from a tokio thread so it can be long-lasting.
pub async fn run_round_coordinator(
	srv: &Arc<Server>,
	mut round_input_rx: mpsc::UnboundedReceiver<(RoundInput, oneshot::Sender<anyhow::Error>)>,
	mut round_trigger_rx: mpsc::Receiver<()>,
) -> anyhow::Result<()> {
	let _worker = srv.rtmgr.spawn_critical("RoundCoordinator");

	let mut round_seq = {
		// we offset by the time of our first release just to slightly reduce
		// absolute number size
		let epoch = UNIX_EPOCH + Duration::from_secs(1741015334);
		RoundSeq::new(SystemTime::now().duration_since(epoch).unwrap().as_secs())
	};

	loop {
		{
			let mut nonce_guard = srv.forfeit_nonces.lock();
			let dropped = nonce_guard.remove_older(srv.config.round_forfeit_nonces_timeout);
			let remaining = nonce_guard.len();
			drop(nonce_guard);
			let nb_dropped = dropped.len();
			let unfinished = dropped.filter(|(_, v)| v.is_some()).count();
			slog!(RoundForfeitNonceCleanup, remaining,
				removed_finished: nb_dropped - unfinished,
				removed_unfinished: unfinished,
			);
		}

		round_seq.increment();
		match perform_round(srv, &mut round_input_rx, round_seq).await {
			RoundResult::Success => {},
			RoundResult::Empty => {},
			// Round got abandoned, immediatelly start a new one.
			RoundResult::Abandoned => continue,
			// Internal error, retry immediatelly.
			RoundResult::Err(RoundError::Recoverable(e)) => {
				error!("Full round error stack trace: {:?}", e);
				slog!(RoundError, round_seq, error: format!("{:#}", e));
				continue;
			},
			// Fatal error, halt operations.
			RoundResult::Err(RoundError::Fatal(e)) => {
				error!("Fatal round error: {:?}", e);
				return Err(e);
			},
		}

		// We sync all wallets now so that we are sure it doesn't interfere with
		// rounds happening.
		if let Err(e) = srv.sync_wallets().await {
			slog!(RoundSyncError, error: format!("{:?}", e));
		};

		// Sleep for the round interval, but discard all incoming messages.
		tokio::pin! { let timeout = tokio::time::sleep(srv.config.round_interval); }
		'sleep: loop {
			tokio::select! {
				() = &mut timeout => break 'sleep,
				Some(()) = round_trigger_rx.recv() => {
					info!("Starting round based on admin RPC trigger");
					break 'sleep;
				},
				_ = round_input_rx.recv() => {},
				_ = srv.rtmgr.shutdown_signal() => {
					info!("Shutdown signal received. Exiting round coordinator loop...");
					return Ok(());
				}
			}
		}
	}
}

impl Server {
	pub async fn register_non_interactive_round_participation(
		&self,
		inputs: Vec<VtxoIdInput>,
		vtxo_requests: Vec<VtxoRequest>,
	) -> anyhow::Result<UnlockHash> {
		let input_ids = inputs.iter().map(|i| i.vtxo_id).collect::<Vec<_>>();

		// we do check the vtxo's spendability in the db call below, but
		// with this, if the user is doing race-y behavior, we can fail early
		// either here or on the other side of the race
		let _guard = match self.vtxos_in_flux.lock(&input_ids) {
			Ok(g) => g,
			Err(v) => return badarg!("vtxo already in flux: {}", v),
		};

		// check input proofs
		let vtxos = self.db.get_vtxos_by_id(&input_ids).await?;
		for (input, vtxo) in inputs.iter().zip(&vtxos) {
			NonInteractiveRoundParticipationChallenge::verify_input_vtxo_sig(
				&vtxo.vtxo, &vtxo_requests, &input.ownership_proof,
			).with_badarg(|| format!("ownership proof for vtxo {} failed", input.vtxo_id))?;
		}

		let unlock_preimage = rand::random::<UnlockPreimage>();
		let unlock_hash = UnlockHash::hash(&unlock_preimage);

		self.db.try_store_round_participation(
			unlock_preimage, &input_ids, &vtxo_requests,
		).await?;

		Ok(unlock_hash)
	}
}

#[cfg(test)]
mod tests {
	use super::*;

	use std::collections::HashSet;
	use std::str::FromStr;

	use bitcoin::Amount;
	use bitcoin::secp256k1::{schnorr, PublicKey, Secp256k1};

	use ark::vtxo::test::VTXO_VECTORS;

	use crate::flux::VtxosInFlux;

	lazy_static::lazy_static! {
		static ref TEST_SIG: schnorr::Signature = schnorr::Signature::from_str(
			"d1c14325e2fe4c44466be57376c4ea093e2d6524503d13be7511e57ec29e13508b507db59dfa9aede12e3e20d120013c268c3af0c7776e0e1e326ae6c9bbc171"
		).unwrap();
	}

	fn generate_pubkey() -> PublicKey {
		let secp = Secp256k1::new();
		let (_secret_key, pubkey) = secp.generate_keypair(&mut rand::thread_rng());
		pubkey
	}

	fn create_signed_req(amount: u64, data: &RoundData) -> SignedVtxoRequest {
		let nonces = {
			let key = Keypair::new(&SECP, &mut rand::thread_rng());
			let (_sec, pb) = musig::nonce_pair(&key);
			vec![pb; data.nb_vtxo_nonces]
		};

		SignedVtxoRequest {
			vtxo: VtxoRequest {
				policy: VtxoPolicy::new_pubkey(generate_pubkey()),
				amount: Amount::from_sat(amount),
			},
			cosign_pubkey: generate_pubkey(),
			nonces: nonces,
		}
	}

	fn create_collecting_payments(max_output_vtxos: usize) -> CollectingPayments {
		let round_data = RoundData {
			max_output_vtxos: max_output_vtxos,
			nb_vtxo_nonces: max_output_vtxos / 3 + 1, // add 1 for rounding
			max_vtxo_amount: None,
		};
		CollectingPayments::new(0.into(), 0, round_data, OwnedVtxoFluxGuard::dummy(), None, None)
	}

	#[test]
	fn test_register_payment_valid() {
		let pre = [1u8; 32];

		let mut state = create_collecting_payments(2);

		let inputs = vec![VTXO_VECTORS.round1_vtxo.clone()];
		let input_ids = inputs
			.iter()
			.map(|v| VtxoIdInput { vtxo_id: v.id(), ownership_proof: *TEST_SIG })
			.collect::<Vec<_>>();

		let outputs = vec![create_signed_req(inputs[0].amount().to_sat(), &state.round_data)];

		state.validate_payment_data(&input_ids, &outputs).unwrap();
		state.validate_payment_amounts(&inputs, &outputs).unwrap();

		let flux = VtxosInFlux::new();
		state.register_interactive_participation(flux.empty_guard(), inputs, outputs.clone(), pre);
		assert_eq!(state.all_inputs.len(), 1);
		assert_eq!(state.all_outputs.len(), 1);
		assert_eq!(state.inputs_per_cosigner.len(), 1);
		assert_eq!(1, state.inputs_per_cosigner.get(&outputs[0].cosign_pubkey).unwrap().len());
	}

	#[test]
	fn test_register_payment_output_exceeds_input() {
		let state = create_collecting_payments(2);

		let inputs = vec![VTXO_VECTORS.round1_vtxo.clone()];
		let input_ids = inputs
			.iter()
			.map(|v| VtxoIdInput { vtxo_id: v.id(), ownership_proof: *TEST_SIG })
			.collect::<Vec<_>>();

		let outputs = vec![create_signed_req(
			inputs[0].amount().to_sat() + 100, &state.round_data,
		)];

		state.validate_payment_data(&input_ids, &outputs).unwrap();
		state.validate_payment_amounts(&inputs, &outputs).unwrap_err();
	}

	#[test]
	fn test_register_payment_duplicate_inputs() {
		let state = create_collecting_payments(2);

		let inputs = vec![
			VTXO_VECTORS.round1_vtxo.clone(), VTXO_VECTORS.round1_vtxo.clone(),
		];
		let input_ids = inputs
			.iter()
			.map(|v| VtxoIdInput { vtxo_id: v.id(), ownership_proof: *TEST_SIG })
			.collect::<Vec<_>>();

		let outputs = vec![create_signed_req(
			inputs[0].amount().to_sat() - 100, &state.round_data,
		)];

		state.validate_payment_data(&input_ids, &outputs).unwrap_err();
	}

	#[test]
	fn test_register_payment_exceeds_max_outputs() {
		let state = create_collecting_payments(1);

		let inputs = vec![VTXO_VECTORS.round1_vtxo.clone(), VTXO_VECTORS.round1_vtxo.clone()];
		let input_ids = inputs
			.iter()
			.map(|v| VtxoIdInput { vtxo_id: v.id(), ownership_proof: *TEST_SIG })
			.collect::<Vec<_>>();

		let outputs = vec![
			create_signed_req(100, &state.round_data),
			create_signed_req(100, &state.round_data),
		];

		state.validate_payment_data(&input_ids, &outputs).unwrap_err();
	}

	#[test]
	fn test_register_payment_disallowed_input() {
		let mut state = create_collecting_payments(2);
		state.allowed_inputs = Some(HashSet::new());

		let inputs = vec![VTXO_VECTORS.round1_vtxo.clone()];
		let input_ids = inputs
			.iter()
			.map(|v| VtxoIdInput { vtxo_id: v.id(), ownership_proof: *TEST_SIG })
			.collect::<Vec<_>>();

		let outputs = vec![create_signed_req(inputs[0].amount().to_sat(), &state.round_data)];

		state.validate_payment_data(&input_ids, &outputs).unwrap_err();
	}

	#[test]
	fn test_register_payment_duplicate_cosign_pubkey() {
		let pre = [1u8; 32];

		let mut state = create_collecting_payments(2);

		let inputs1 = vec![VTXO_VECTORS.round1_vtxo.clone()];
		let input_ids1 = inputs1
			.iter()
			.map(|v| VtxoIdInput { vtxo_id: v.id(), ownership_proof: *TEST_SIG })
			.collect::<Vec<_>>();
		let inputs2 = vec![VTXO_VECTORS.arkoor_htlc_out_vtxo.clone()];
		let input_ids2 = inputs2
			.iter()
			.map(|v| VtxoIdInput { vtxo_id: v.id(), ownership_proof: *TEST_SIG })
			.collect::<Vec<_>>();

		let outputs1 = vec![create_signed_req(inputs1[0].amount().to_sat(), &state.round_data)];
		let mut outputs2 = vec![create_signed_req(inputs2[0].amount().to_sat(), &state.round_data)];
		outputs2[0].cosign_pubkey = outputs1[0].cosign_pubkey;

		let flux = VtxosInFlux::new();
		state.validate_payment_data(&input_ids1, &outputs1).unwrap();
		state.register_interactive_participation(flux.empty_guard(), inputs1, outputs1, pre);
		state.validate_payment_data(&input_ids2, &outputs2).unwrap_err();
	}

	#[test]
	fn test_register_wrong_nb_cosign_nonces() {
		let state = create_collecting_payments(4);

		let inputs1 = vec![VTXO_VECTORS.round1_vtxo.clone()];
		let input_ids1 = inputs1
			.iter()
			.map(|v| VtxoIdInput { vtxo_id: v.id(), ownership_proof: *TEST_SIG })
			.collect::<Vec<_>>();

		let mut wrong_round_data = state.round_data.clone();
		wrong_round_data.nb_vtxo_nonces = state.round_data.nb_vtxo_nonces + 1;
		let outputs1 = vec![
			create_signed_req(100, &wrong_round_data),
			create_signed_req(100, &wrong_round_data),
		];

		state.validate_payment_data(&input_ids1, &outputs1).unwrap_err();
	}

	#[test]
	fn test_register_multiple_payments() {
		let pre1 = [1u8; 32];
		let pre2 = [2u8; 32];

		let mut state = create_collecting_payments(4);

		let inputs1 = vec![VTXO_VECTORS.round1_vtxo.clone()];
		let input_ids1 = inputs1
			.iter()
			.map(|v| VtxoIdInput { vtxo_id: v.id(), ownership_proof: *TEST_SIG })
			.collect::<Vec<_>>();
		let inputs2 = vec![VTXO_VECTORS.arkoor_htlc_out_vtxo.clone()];
		let input_ids2 = inputs2
			.iter()
			.map(|v| VtxoIdInput { vtxo_id: v.id(), ownership_proof: *TEST_SIG })
			.collect::<Vec<_>>();

		let outputs1 = vec![
			create_signed_req(100, &state.round_data),
			create_signed_req(100, &state.round_data),
		];
		let outputs2 = vec![
			create_signed_req(100, &state.round_data),
			create_signed_req(100, &state.round_data),
		];

		let flux = VtxosInFlux::new();
		state.validate_payment_data(&input_ids1, &outputs1).unwrap();
		state.register_interactive_participation(flux.empty_guard(), inputs1, outputs1.clone(), pre1);
		state.validate_payment_data(&input_ids2, &outputs2).unwrap();
		state.register_interactive_participation(flux.empty_guard(), inputs2, outputs2.clone(), pre2);

		assert_eq!(state.all_inputs.len(), 2);
		assert_eq!(state.all_outputs.len(), 4);
		assert_eq!(state.inputs_per_cosigner.len(), 4);
		assert!(state.inputs_per_cosigner.contains_key(&outputs1[0].cosign_pubkey));
		assert!(state.inputs_per_cosigner.contains_key(&outputs2[0].cosign_pubkey));
		assert!(state.proceed, "Proceed should be set after second registration");
	}
}
